<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>REPAIR OCR v5.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script async src="opencv_v1.js" onload="onOpenCvReady();"></script>
</head>

<body class="bg-slate-950 text-slate-100 min-h-screen font-mono text-[10px] overflow-hidden">

    <div
        class="fixed top-0 left-0 right-0 z-50 bg-black/90 backdrop-blur p-2 border-b border-slate-800 flex justify-between items-center px-4">
        <div class="flex flex-col">
            <span id="setup-status" class="text-red-500 font-bold tracking-tighter text-[9px]">● ENGINE
                LOADING...</span>
            <span id="ocr-status" class="text-slate-500 text-[8px]">OCR: INITIALIZING...</span>
        </div>
        <span class="text-orange-500 font-black italic tracking-widest">REPAIR MODE v5.0</span>
    </div>

    <main class="max-w-md mx-auto pt-14 p-4 h-screen flex flex-col">

        <div
            class="relative rounded-3xl overflow-hidden aspect-[4/3] bg-black shadow-2xl border border-slate-800 shrink-0">
            <video id="video" autoplay playsinline class="w-full h-full object-cover"></video>

            <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div
                    class="w-[90%] h-24 border-2 border-orange-500/80 rounded-lg shadow-[0_0_20px_rgba(249,115,22,0.4)] flex items-center justify-center bg-orange-500/5">
                    <div class="w-full h-[1px] bg-orange-400/30 animate-pulse"></div>
                </div>
            </div>

            <div id="loader" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center hidden">
                <div class="w-10 h-10 border-4 border-orange-500 border-t-transparent rounded-full animate-spin"></div>
                <p id="progress-text" class="mt-4 text-orange-400 font-bold uppercase tracking-widest">Repairing &
                    Reading...</p>
            </div>
        </div>

        <div class="mt-4 bg-slate-900 rounded-xl p-2 border border-slate-800 shrink-0 shadow-inner">
            <div class="flex justify-between items-center mb-1">
                <p class="text-[8px] text-orange-400 uppercase font-bold tracking-widest">AI Vision (Dilation Process)
                </p>
                <p class="text-[7px] text-slate-600 italic">文字を太らせて接続中</p>
            </div>
            <canvas id="canvas-debug"
                class="w-full h-16 bg-black rounded object-contain border border-slate-950"></canvas>
        </div>

        <div class="mt-4 flex-grow flex flex-col space-y-3 min-h-0">
            <button id="scan-btn" disabled
                class="w-full py-5 bg-slate-800 text-slate-500 rounded-2xl font-black text-xl transition-all shadow-lg active:scale-95 shrink-0">
                BOOTING...
            </button>

            <div class="bg-slate-900 p-4 rounded-2xl border border-slate-800 flex-grow overflow-y-auto relative">
                <label
                    class="absolute -top-2 left-4 px-2 bg-slate-950 text-orange-400 text-[8px] font-bold uppercase">OCR
                    Result (Hybrid JPN/ENG)</label>
                <div id="ocr-result" class="text-xs leading-relaxed break-all whitespace-pre-wrap pt-2 text-slate-100">
                    ガイド枠に「かすれ」がある文字を収めてください。自動で線を補修して読み取ります。
                </div>
            </div>
        </div>
    </main>

    <canvas id="canvas-proc" class="hidden"></canvas>

    <script>
        const video = document.getElementById('video');
        const scanBtn = document.getElementById('scan-btn');
        const ocrResult = document.getElementById('ocr-result');
        const loader = document.getElementById('loader');
        const progressText = document.getElementById('progress-text');
        const debugCanvas = document.getElementById('canvas-debug');
        const setupStatus = document.getElementById('setup-status');
        const ocrStatus = document.getElementById('ocr-status');

        let cvReady = false;
        let worker = null;

        function onOpenCvReady() {
            cvReady = true;
            setupStatus.innerText = "● CV READY";
            setupStatus.classList.replace('text-red-500', 'text-green-500');
            checkEngines();
        }

        async function initOCR() {
            ocrStatus.innerText = "OCR: LOADING JPN/ENG...";
            worker = await Tesseract.createWorker('jpn+eng', 1);

            // 【重要】単一の均一なテキストブロックとして認識 (PSM 6)
            await worker.setParameters({
                tessedit_pageseg_mode: '6',
            });

            ocrStatus.innerText = "OCR: HYBRID READY";
            ocrStatus.className = "text-green-500 text-[8px]";
            checkEngines();
        }

        function checkEngines() {
            if (cvReady && worker) {
                scanBtn.disabled = false;
                scanBtn.innerText = "スキャン実行";
                scanBtn.classList.replace('bg-slate-800', 'bg-orange-600');
                scanBtn.classList.replace('text-slate-500', 'text-white');
            }
        }

        navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'environment',
                width: { ideal: 1920, min: 1280 },
                height: { ideal: 1080, min: 720 }
            }
        }).then(s => video.srcObject = s);

        initOCR();

        scanBtn.onclick = async () => {
            if (!cvReady || !worker) return;
            loader.classList.remove('hidden');
            ocrResult.innerText = "傾き補正・解析中...";

            try {
                const canvas = document.getElementById('canvas-proc');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // ROI切り出し
                const roiW = canvas.width * 0.90;
                const roiH = canvas.height * 0.30; // 少し広めに変更（傾き対応）
                const roiX = (canvas.width - roiW) / 2;
                const roiY = (canvas.height - roiH) / 2;

                const roiCanvas = document.createElement('canvas');
                roiCanvas.width = roiW;
                roiCanvas.height = roiH;
                const roiCtx = roiCanvas.getContext('2d');
                roiCtx.drawImage(canvas, roiX, roiY, roiW, roiH, 0, 0, roiW, roiH);

                // --- OpenCV 文字補修・デスクー（傾き補正）プロセス ---
                let mat = cv.imread(roiCanvas);
                cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);

                // 1. 高解像度スケーリング
                let scale = 1500 / mat.cols;
                let dsize = new cv.Size(1500, Math.round(mat.rows * scale));
                cv.resize(mat, mat, dsize, 0, 0, cv.INTER_LANCZOS4);

                // 2. 正規化 & CLAHE
                cv.normalize(mat, mat, 0, 255, cv.NORM_MINMAX);
                let clahe = new cv.CLAHE(3.5, new cv.Size(8, 8));
                clahe.apply(mat, mat);
                clahe.delete();

                // 3. アンシャープマスク
                let blurred = new cv.Mat();
                cv.GaussianBlur(mat, blurred, new cv.Size(9, 9), 2);
                cv.addWeighted(mat, 2.0, blurred, -1.0, 0, mat);
                blurred.delete();

                // 4. 二値化 (一時的な二値化で角度を判定)
                let tempMat = new cv.Mat();
                cv.threshold(mat, tempMat, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU);

                // --- 自動傾き補正 (Deskew) ---
                let angle = 0;
                try {
                    let points = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(tempMat, points, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    if (points.size() > 0) {
                        // すべての輪郭をまとめた大きな輪郭を擬似的に作成
                        let allPoints = [];
                        for (let i = 0; i < points.size(); ++i) {
                            let cnt = points.get(i);
                            let rect = cv.boundingRect(cnt);
                            if (rect.width > 20 && rect.height > 20) {
                                // 代表的な点だけを抽出（性能のため）
                                allPoints.push(new cv.Point(rect.x, rect.y));
                                allPoints.push(new cv.Point(rect.x + rect.width, rect.y + rect.height));
                            }
                        }

                        if (allPoints.length > 0) {
                            let matPoints = cv.matFromArray(allPoints.length, 1, cv.CV_32SC2, allPoints.flatMap(p => [p.x, p.y]));
                            let rotatedRect = cv.minAreaRect(matPoints);
                            angle = rotatedRect.angle;
                            if (angle < -45) angle += 90;
                            // 傾きが強すぎる場合は無視（誤判定防止）
                            if (Math.abs(angle) > 30) angle = 0;
                            matPoints.delete();
                        }
                    }
                    points.delete();
                    hierarchy.delete();
                } catch (e) {
                    console.warn("Deskew analysis failed", e);
                }
                tempMat.delete();

                // 角度があれば補正（回転）
                if (Math.abs(angle) > 0.5) {
                    let center = new cv.Point(mat.cols / 2, mat.rows / 2);
                    let M_rot = cv.getRotationMatrix2D(center, angle, 1);
                    cv.warpAffine(mat, mat, M_rot, new cv.Size(mat.cols, mat.rows), cv.INTER_CUBIC, cv.BORDER_REPLICATE);
                    M_rot.delete();
                }

                // 5. 本番の二値化 (Hybrid)
                let adaptiveMat = new cv.Mat();
                let otsuMat = new cv.Mat();
                cv.adaptiveThreshold(mat, adaptiveMat, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 51, 15);
                cv.threshold(mat, otsuMat, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU);
                cv.bitwise_and(adaptiveMat, otsuMat, mat);
                adaptiveMat.delete();
                otsuMat.delete();

                // 6. モルフォロジー (クロージング)
                let M_close = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(mat, mat, cv.MORPH_CLOSE, M_close);
                M_close.delete();

                // 7. 最終クロップ
                let finalMat = new cv.Mat();
                let tableFound = false;
                try {
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(mat, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    if (contours.size() > 0) {
                        let minX = mat.cols, minY = mat.rows, maxX = 0, maxY = 0;
                        for (let i = 0; i < contours.size(); ++i) {
                            let rect = cv.boundingRect(contours.get(i));
                            if (rect.height > 10 && rect.width > 10) {
                                minX = Math.min(minX, rect.x);
                                minY = Math.min(minY, rect.y);
                                maxX = Math.max(maxX, rect.x + rect.width);
                                maxY = Math.max(maxY, rect.y + rect.height);
                            }
                        }
                        if (maxX > minX && maxY > minY) {
                            let pad = 20;
                            minX = Math.max(0, minX - pad);
                            minY = Math.max(0, minY - pad);
                            maxX = Math.min(mat.cols, maxX + pad);
                            maxY = Math.min(mat.rows, maxY + pad);
                            let tightRect = new cv.Rect(minX, minY, maxX - minX, maxY - minY);
                            let cropped = mat.roi(tightRect);
                            cropped.copyTo(finalMat);
                            cropped.delete();
                            tableFound = true;
                        }
                    }
                    contours.delete();
                    hierarchy.delete();
                } catch (e) {
                    console.warn("Final crop failed", e);
                }

                if (!tableFound) mat.copyTo(finalMat);

                cv.copyMakeBorder(finalMat, finalMat, 50, 50, 50, 50, cv.BORDER_CONSTANT, [0, 0, 0, 255]);
                cv.bitwise_not(finalMat, finalMat);

                cv.imshow('canvas-debug', finalMat);
                const { data: { text } } = await worker.recognize(document.getElementById('canvas-debug'));

                mat.delete();
                finalMat.delete();

                const cleanText = text.replace(/\s+/g, ' ').trim();
                ocrResult.innerText = cleanText || "再試行してください（枠内に収める・水平に撮る）";

            } catch (err) {
                console.error(err);
                ocrResult.innerText = "ERR: " + err.message;
            } finally {
                loader.classList.add('hidden');
            }
        };
    </script>
</body>

</html>
